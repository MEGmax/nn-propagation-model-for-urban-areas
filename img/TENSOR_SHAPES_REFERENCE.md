# Input Tensor Specifications for Diffusion Model

## Complete Data Format Overview

### 1. **Elevation Map** ðŸ—»
```
Shape: (H, W)
Type: float32
Range: [0.0, 1.0] (normalized)
Details:
  â€¢ Orthographic projection of mesh vertices to grid
  â€¢ Height normalized: (z - z_min) / (z_max - z_min)
  â€¢ z_max typically ~27.6m (tallest building)
  â€¢ 0 = ground level, 1 = tallest building
  â€¢ CRITICAL: Also appears as cond[0] in conditioning tensor
```

**Example 64Ã—64 grid:**
```
[[0.0,  0.0,  0.0,  0.0, ...],     â† Ground level (no buildings)
 [0.0,  0.15, 0.25, 0.20, ...],     â† Building shadow
 [0.0,  0.18, 0.30, 0.25, ...],     â† Taller building
 [0.0,  0.0,  0.0,  0.0, ...],      â† More ground
 ...]
```

---

### 2. **RF Data / Transmitter Heatmap** ðŸ“¡
```
Shape: (H, W)
Type: float32
Range: [0.0, 1.0] (normalized Gaussian)
Details:
  â€¢ 2D Gaussian centered at transmitter location (tx_x, tx_y)
  â€¢ Formula: exp(-((x - tx_x)Â² + (y - tx_y)Â²) / (2ÏƒÂ²))
  â€¢ Ïƒ (sigma): ~8-14 pixels (configurable)
  â€¢ Peak value: 1.0 at transmitter
  â€¢ Value @ 2Ïƒ distance: ~0.135
  â€¢ Encodes both: location AND coverage falloff
```

**Example heatmap (Ïƒ=10px, center at 32,32 in 64Ã—64 grid):**
```
[[0.00, 0.00, 0.01, 0.02, 0.03, ...],     â† Far from TX
 [0.00, 0.05, 0.10, 0.15, 0.20, ...],     
 [0.01, 0.10, 0.40, 0.60, 0.75, ...],     â† Near TX, values rising
 [0.02, 0.15, 0.60, 1.00, 0.90, ...],     â† Peak at TX (1.0)
 [0.03, 0.20, 0.75, 0.90, 0.80, ...],
 ...]
```

**Gaussian calculation in Python:**
```python
yy, xx = np.meshgrid(np.arange(H), np.arange(W), indexing='ij')
sigma = 10.0
tx_x, tx_y = 32, 32  # Transmitter location
tx_heatmap = np.exp(-((xx - tx_x)**2 + (yy - tx_y)**2) / (2 * sigma**2))
```

---

### 3. **Material Data** ðŸ¢
```
Shape: (M, H, W)  where M = number of material types
Type: float32
Range: [0.0, 1.0] (binary one-hot per pixel)
Details:
  â€¢ M = number of distinct materials in scene (typically 2-5)
  â€¢ Each channel represents one material type
  â€¢ Value = 1.0 if pixel contains that material, 0.0 otherwise
  â€¢ Can be multi-material (overlapping) in some implementations
```

**Example with 3 materials (M=3, 64Ã—64 grid):**
```
Material[0] - Concrete/Ground:
[[1.0, 1.0, 1.0, 1.0, ...],     â† Ground everywhere
 [1.0, 1.0, 1.0, 1.0, ...],
 ...]

Material[1] - Building Metal/Walls:
[[0.0, 0.0, 0.0, 0.0, ...],     â† No metal on ground
 [0.0, 1.0, 1.0, 1.0, ...],     â† Metal in building
 [0.0, 1.0, 1.0, 1.0, ...],
 ...]

Material[2] - Glass/Windows:
[[0.0, 0.0, 0.0, 0.0, ...],     â† No glass on ground
 [0.0, 0.0, 0.1, 0.2, ...],     â† Some glass in building
 [0.0, 0.0, 0.2, 0.3, ...],
 ...]
```

**Attenuation factors (typical):**
- Concrete: -3 dB/material
- Metal: -10 dB/material
- Glass: -2 dB/material

---

### 4. **RSS Map (Ground Truth)** ðŸ“¶
```
Shape: (1, H, W)
Type: float32
Range: [-1.0, 1.0] (normalized)
Details:
  â€¢ Received Signal Strength in dB
  â€¢ Generated by Sionna ray-tracing simulator
  â€¢ Raw values: ~-30 dB (near TX) to -100 dB (far/blocked)
  â€¢ Normalization formula:
    rss_norm = (rss_db + |RSS_DB_FLOOR|) / RSS_DB_SCALE
    where RSS_DB_FLOOR = -100.0, RSS_DB_SCALE = 50.0
  â€¢ Clipped to [-1.0, 1.0]
```

**Normalization example:**
```python
RSS_DB_FLOOR = -100.0  # Weakest detectable signal
RSS_DB_SCALE = 50.0    # Range normalization

# Raw ray-traced values (dB)
rss_raw = -30.0  # Strong signal near TX
# Normalized:
rss_norm = (-30.0 - (-100.0)) / 50.0 = 70.0 / 50.0 = 1.4
# Clipped:
rss_clipped = clip(1.4, -1.0, 1.0) = 1.0

rss_raw = -80.0  # Weak signal far away
rss_norm = (-80.0 - (-100.0)) / 50.0 = 20.0 / 50.0 = 0.4
rss_clipped = 0.4
```

**Example RSS map (64Ã—64 grid):**
```
[[-0.8, -0.8, -0.7, -0.6, ...],     â† Weak (blue, far from TX)
 [-0.8, -0.2,  0.3,  0.6, ...],     
 [-0.7,  0.3,  0.8,  1.0, ...],     â† Strong (red, near TX)
 [-0.6,  0.6,  1.0,  0.9, ...],     â† Peak signal
 [-0.5,  0.5,  0.95, 0.85, ...],
 ...]
```

---

## Complete Dataset Sample Structure

### What gets saved to `.npy` file:
```python
sample = {
    "rss": rss,              # Shape: (1, H, W)
    "cond": cond,            # Shape: (C_cond, H, W)
    "elevation": elevation   # Shape: (H, W)
}
np.save("sample.npy", sample)
```

### The `cond` tensor breakdown:
```
cond = (C_cond, H, W)

Channel breakdown:
cond[0] = elevation          # (H, W) - ALWAYS FIRST!
cond[1] = tx_heatmap         # (H, W) - Transmitter location
cond[2] = material_0         # (H, W) - e.g., concrete
cond[3] = material_1         # (H, W) - e.g., metal
cond[4] = material_2         # (H, W) - e.g., glass
...
cond[M+1] = material_M       # (H, W) - Last material

C_cond = 2 + M  where M = number of materials

Typical example (3 materials):
C_cond = 2 + 3 = 5 channels
```

---

## Loading from Disk

```python
import numpy as np

# Load sample
data = np.load("sample.npy", allow_pickle=True).item()

# Extract tensors
rss = data['rss']              # (1, 64, 64)
cond = data['cond']            # (5, 64, 64) for 3 materials
elevation = data['elevation']  # (64, 64)

# Verify shapes
print(f"RSS shape: {rss.shape}")           # (1, 64, 64)
print(f"Cond shape: {cond.shape}")         # (5, 64, 64)
print(f"Elevation shape: {elevation.shape}") # (64, 64)
print(f"Num materials: {cond.shape[0] - 2}") # 3
```

---

## Visual Representation (What Each Channel Looks Like)

### Elevation Map (Grayscale)
```
0 (Black) = Ground
1 (White) = Tall building
Shows: Urban geometry/buildings
```

### TX Heatmap (Heat map)
```
0 (Blue) = Far from transmitter
0.5 (Yellow) = Medium distance
1 (Red) = At transmitter
Shows: Coverage proximity/signal falloff
```

### Material Channels (Binary masks)
```
0 (Black) = No material here
1 (White) = Material present
Shows: Where specific materials are located
```

### RSS Map (Heat map)
```
-1 (Dark Blue) = Very weak signal
0 (Green) = Medium signal
1 (Red) = Strong signal
Shows: Predicted received signal strength
```

---

## Typical Grid Resolutions

```
Grid Size    Physical Coverage  Pixels/meter
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
64Ã—64        30m Ã— 30m          ~2.1 px/m
128Ã—128      64m Ã— 64m          ~2.0 px/m
256Ã—256      128m Ã— 128m        ~2.0 px/m
```

**At 0.5 m/pixel resolution:**
- 1 meter = 2 pixels
- 10 meter building = 20 pixels tall
- Transmitter Ïƒ = 10 pixels â‰ˆ 5 meter radius

---

## Data Flow in Model Training

```
INPUT TO MODEL:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ cond tensor: (C_cond, H, W)                 â”‚
â”‚  â”œâ”€ cond[0]: elevation map (H, W)           â”‚
â”‚  â”œâ”€ cond[1]: TX heatmap (H, W)              â”‚
â”‚  â”œâ”€ cond[2:]: material maps (H, W each)     â”‚
â”‚                                             â”‚
â”‚ rss_t tensor: (1, H, W)                     â”‚
â”‚  â””â”€ Noisy RSS at diffusion step t           â”‚
â”‚                                             â”‚
â”‚ t tensor: scalar (diffusion timestep)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
    TimeCondUNet
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Output: (1, H, W)                           â”‚
â”‚  â””â”€ Predicted noise                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Key Constraints (CRITICAL for Implementation)

```
âš ï¸ MUST VERIFY:
âœ“ cond[0] is ALWAYS elevation (required for FiLM modulation)
âœ“ rss shape is EXACTLY (1, H, W) not (H, W)
âœ“ All tensors are float32 (not float64 or int)
âœ“ Elevation normalized to [0, 1] not [-1, 1]
âœ“ RSS normalized to [-1, 1] using formula above
âœ“ TX heatmap has peak of 1.0 at transmitter location
âœ“ All H, W dimensions match across all tensors
```

---

## Example: Creating Sample from Scratch

```python
import numpy as np

# Configuration
H, W = 64, 64
num_materials = 3

# 1. Create elevation map
elevation = np.random.rand(H, W).astype(np.float32) * 0.3  # [0, 0.3]
# Normalize to [0, 1]
elevation = (elevation - elevation.min()) / (elevation.max() - elevation.min())

# 2. Create TX heatmap
tx_x, tx_y = 32, 32  # Transmitter at center
sigma = 10.0
yy, xx = np.meshgrid(np.arange(H), np.arange(W), indexing='ij')
tx_heatmap = np.exp(-((xx - tx_x)**2 + (yy - tx_y)**2) / (2 * sigma**2)).astype(np.float32)

# 3. Create material maps (random for demo)
material_maps = np.random.rand(num_materials, H, W).astype(np.float32)
material_maps = (material_maps > 0.5).astype(np.float32)  # Binarize

# 4. Assemble cond tensor
cond = np.concatenate([
    elevation[None, ...],           # cond[0]
    tx_heatmap[None, ...],          # cond[1]
    material_maps                   # cond[2:]
], axis=0).astype(np.float32)

# 5. Create RSS map (dummy example)
rss_raw = -30 * tx_heatmap  # Dummy: decay from TX
RSS_DB_FLOOR = -100.0
RSS_DB_SCALE = 50.0
rss_norm = (rss_raw + abs(RSS_DB_FLOOR)) / RSS_DB_SCALE
rss = np.clip(rss_norm, -1.0, 1.0)[None, ...].astype(np.float32)

# 6. Create sample dict
sample = {
    "rss": rss,                      # Shape: (1, 64, 64)
    "cond": cond,                    # Shape: (5, 64, 64)
    "elevation": elevation           # Shape: (64, 64)
}

# 7. Save
np.save("sample_demo.npy", sample)
print(f"Saved sample with shapes:")
print(f"  rss: {sample['rss'].shape}")
print(f"  cond: {sample['cond'].shape}")
print(f"  elevation: {sample['elevation'].shape}")
```

**Output:**
```
Saved sample with shapes:
  rss: (1, 64, 64)
  cond: (5, 64, 64)
  elevation: (64, 64)
```

---

## Summary Table

| Tensor | Shape | Type | Range | Meaning |
|--------|-------|------|-------|---------|
| **Elevation** | (H, W) | float32 | [0, 1] | Height map: 0=ground, 1=tallest |
| **TX Heatmap** | (H, W) | float32 | [0, 1] | Location: 1 at TX, decays outward |
| **Materials** | (M, H, W) | float32 | {0, 1} | One-hot per material type |
| **RSS (Input)** | (1, H, W) | float32 | [-1, 1] | Ground truth signal strength |
| **Cond (Stacked)** | (2+M, H, W) | float32 | Mixed | All conditioning info stacked |

